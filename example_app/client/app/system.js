// Note: This file was auto-generated by SocketStream at 1365666700325
// Do not modify!

module.exports = function(app) {

  // PASS THROUGH CONFIG
  app.env = 'development';

  // DEFINE TRANSPORT
  var transport = function (options) {

  options = options || {};
  options.protocol = options.protocol || 'ws';
  options.host = options.host || 'localhost';

  options.reconnection = options.reconnection || {
    attempts: Infinity,
    minDelay: 1000,
    maxDelay: 8000
  };
  
  var attemptReconnect = true;
  var reconnectionAttempts = 0;
  var reconnecting = false;

  function debug() {
    var args = Array.prototype.slice.call(arguments);
    if (options.debug) console.log.apply(console, args);
  }

  // Connect
  return function (client) {

    var ws;
    var url = options.protocol + '://' + options.host + ':' + options.port;

    function connect(){

      debug('Connecting to', url);
      
      ws = new WebSocket(url);

      ws.onopen = function() {
        return client.status.emit('open');
      };

      ws.onmessage = function(obj, flags) {
        // flags.binary will be set if a binary data is received
        // flags.masked will be set if the data was masked
        debug('RECV', obj.data);
        client.process({message: obj.data});
      };

      ws.onclose = function() {
        client.status.emit('close');
        reconnect();
      };

    }

    function reconnect() {
      if (!attemptReconnect) return;

      // Attempt reconnection
      // Note: most of this logic is from socket.io-client at the moment
      reconnectionAttempts++;

      if (reconnectionAttempts > options.reconnection.attemps) {
        client.status.emit('reconnect_failed');
        reconnecting = false;
      } else {
        var delay = reconnectionAttempts * options.reconnection.minDelay;
        delay = Math.min(delay, options.reconnection.maxDelay);
        debug('Waiting %dms before reconnect attempt', delay);

        reconnecting = true;
        var timer = setTimeout(function(){
          debug('Attempting reconnect...');
          connect();
        }, delay);
      }
    }

    connect();

    // Return API
    return {

      disconnect: function() {
        attemptReconnect = false;
        ws.close();
      },

      write: function(msg) {
        debug('SEND', msg);
        ws.send(msg);
      }

    };

  };

};

  app.transport = transport({"port":3001});
  // DEFINE SERVICES

  // livereload service
  app.provide({"id":1,"name":"livereload","options":{},"use":{}}, function (client) {

  client.onmessage = function(msg) {

    // Reload browser if reload system event received
    switch (msg) {
      case 'reload':
        window.location.reload();
        break;
      case 'updateCSS':
        var tags = document.getElementsByTagName("link");
        for (var i = 0; i < tags.length; i++) {
          var tag = tags[i];
          if (tag.rel.toLowerCase().indexOf("stylesheet") >= 0 && tag.href) {
            var h = tag.href.replace(/(&|%5C?)\d+/, "");
            tag.href = h + (h.indexOf("?") >= 0 ? "&" : "?") + (new Date().valueOf());
          }
        }
        break;
    }
  };

});

  // pubsub service
  app.provide({"id":2,"name":"pubsub","options":{},"use":{"json":true,"sessions":true}}, function (client) {

  var EE = require('events').EventEmitter;
  var ee = new EE();

  client.onmessage = function(obj) {
    ee.emit(obj.e, obj.p);
  };

  return ee;

});

  // rpc service
  app.provide({"id":3,"name":"rpc","options":{},"use":{"json":true,"callbacks":true,"sessions":true}}, function (client) {

  function defaultCallback(x) {
    return console.log(x);
  }

  // Return API to call functions on the server
  return function() {
    var args = Array.prototype.slice.call(arguments);

    var msg = { m: args[0] };
    var lastArg = args[args.length - 1];

    var cb;
    if (typeof lastArg === 'function') {
      msg.p = args.slice(1, args.length - 1);
      cb = lastArg;
    } else {
      msg.p = args.slice(1);
      cb = defaultCallback;
    }

    client.send(msg, function(obj){
      if (obj.e) {
        console.error('RPC server error:', obj.e.message);
      } else {
        cb.apply(cb, obj.p);
      }
    });

    // Always return 'undefined'      
    return void 0;
  };

});

  // square service
  app.provide({"id":4,"name":"square","options":{},"use":{"callbacks":true}}, function (client){

      // invoke this function with ss.square() on the client
      return function(question) {
        client.send(question, function(answer){
          alert(answer);
        });
      };

    });

  return app;
};
